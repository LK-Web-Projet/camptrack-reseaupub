
import { signAccessToken } from "@/lib/auth/jwt";
import { prisma } from "@/lib/prisma";

const API_URL = "http://localhost:3000/api";

async function main() {
    console.log("ðŸš€ Starting verification script...");

    // 1. Check if server is running
    try {
        const healthCheck = await fetch(`${API_URL}/docs`); // or any public route
        if (!healthCheck.ok && healthCheck.status !== 401 && healthCheck.status !== 403) {
            // 401/403 means server is up but auth failed, which is fine for connectivity check
        }
    } catch (error) {
        console.error("âŒ Link connection failed. Is the server running on http://localhost:3000?");
        console.error("ðŸ‘‰ Please run 'npm run dev' in a separate terminal.");
        process.exit(1);
    }

    // 2. Get Admin User for Token
    const adminUser = await prisma.user.findFirst({
        where: { type_user: "ADMIN" },
    });

    if (!adminUser) {
        console.error("âŒ No ADMIN user found in database. Cannot generate token.");
        process.exit(1);
    }

    const token = signAccessToken({
        userId: adminUser.id_user,
        email: adminUser.email,
        role: adminUser.type_user,
    });

    const headers = {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${token}`,
    };

    console.log("âœ… Authenticated as:", adminUser.email);

    // 3. Get a Prestataire
    const prestataire = await prisma.prestataire.findFirst();
    if (!prestataire) {
        console.error("âŒ No Prestataire found. Please seed the database.");
        process.exit(1);
    }

    // 4. Create TypeIncident
    console.log("\nðŸ§ª Testing TypeIncident CRUD...");
    const typeRes = await fetch(`${API_URL}/types-incidents`, {
        method: "POST",
        headers,
        body: JSON.stringify({
            nom: `Test Type ${Date.now()}`,
            description: "Generated by verification script"
        }),
    });

    if (!typeRes.ok) {
        console.error("âŒ Failed to create TypeIncident:", await typeRes.text());
        process.exit(1);
    }

    const typeData = await typeRes.json();
    const typeId = typeData.id_type_incident;
    console.log("âœ… Created TypeIncident:", typeId);


    // 5. Create Incident
    console.log("\nðŸ§ª Testing Incident CRUD...");
    const incidentRes = await fetch(`${API_URL}/incidents`, {
        method: "POST",
        headers,
        body: JSON.stringify({
            id_prestataire: prestataire.id_prestataire,
            id_type_incident: typeId,
            date_incident: new Date().toISOString(),
            commentaire: "Initial comment",
            photos: []
        }),
    });

    if (!incidentRes.ok) {
        console.error("âŒ Failed to create Incident:", await incidentRes.text());
        process.exit(1);
    }

    const incidentData = await incidentRes.json();
    const incidentId = incidentData.id_incident;
    console.log("âœ… Created Incident:", incidentId);


    // 6. UPDATE Incident (PUT) - The NEW functionality
    const updateRes = await fetch(`${API_URL}/incidents/${incidentId}`, {
        method: "PUT",
        headers,
        body: JSON.stringify({
            id_prestataire: prestataire.id_prestataire,
            id_type_incident: typeId,
            date_incident: new Date().toISOString(),
            commentaire: "Updated comment by script", // Changed
        }),
    });

    if (!updateRes.ok) {
        console.error("âŒ Failed to UPDATE Incident:", await updateRes.text());
        process.exit(1);
    }

    const updatedIncident = await updateRes.json();
    if (updatedIncident.commentaire === "Updated comment by script") {
        console.log("âœ… Verified Incident UPDATE (PUT)");
    } else {
        console.error("âŒ Incident update mismatch:", updatedIncident);
    }


    // 7. UPDATE TypeIncident (PUT) - The NEW functionality
    const updateTypeRes = await fetch(`${API_URL}/types-incidents/${typeId}`, {
        method: "PUT",
        headers,
        body: JSON.stringify({
            nom: `Updated Type ${Date.now()}`,
            description: "Updated description"
        }),
    });

    if (!updateTypeRes.ok) {
        console.error("âŒ Failed to UPDATE TypeIncident:", await updateTypeRes.text());
        process.exit(1);
    }
    console.log("âœ… Verified TypeIncident UPDATE (PUT)");


    // 8. DELETE Incident - The NEW functionality
    const deleteIncidentRes = await fetch(`${API_URL}/incidents/${incidentId}`, {
        method: "DELETE",
        headers,
    });

    if (!deleteIncidentRes.ok) {
        console.error("âŒ Failed to DELETE Incident:", await deleteIncidentRes.text());
        process.exit(1);
    }
    console.log("âœ… Verified Incident DELETE");

    // Verify it's gone
    const checkIncident = await prisma.incident.findUnique({ where: { id_incident: incidentId } });
    if (!checkIncident) {
        console.log("âœ… Incident confirmed deleted from DB");
    } else {
        console.error("âŒ Incident still exists in DB!");
    }


    // 9. DELETE TypeIncident - The NEW functionality
    const deleteTypeRes = await fetch(`${API_URL}/types-incidents/${typeId}`, {
        method: "DELETE",
        headers,
    });

    if (!deleteTypeRes.ok) {
        console.error("âŒ Failed to DELETE TypeIncident:", await deleteTypeRes.text());
        process.exit(1);
    }
    console.log("âœ… Verified TypeIncident DELETE");

    console.log("\nðŸŽ‰ All CRUD tests passed successfully!");
}

main()
    .catch((e) => {
        console.error(e);
        process.exit(1);
    })
    .finally(async () => {
        await prisma.$disconnect();
    });
